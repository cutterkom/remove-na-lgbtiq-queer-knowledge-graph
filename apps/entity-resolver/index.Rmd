---
title: "Who Is Who?"
output: 
  flexdashboard::flex_dashboard:
    orientation: column
    vertical_layout: fill
runtime: shiny
---

```{r setup, include=FALSE}
library(flexdashboard)
library(tidyverse)
library(kabrutils)
library(DBI)


#load("apps/entity-resolver/data/candidates-authors.Rdata")
load("data/candidates-authors.Rdata")

#source("get_infos.R")
```

```{r}
#' get a candidate pair to check
#' 
#' rule to choose
#' - not yet checked: `decision == "no_judgement"`
#' - minimum rank: highest similarity
#' - minimum id: in order to choose when similar rank
#' 
#' @param data dataframe with similarties
#' @return dataframe with 1 row
#' 
get_candidates_to_check <- function(data) {
  data %>% 
    dplyr::filter(decision == "no_judgement" & rank == min(rank), row_number() == 1)
}


#' Get candidates names
#' 
#' Looks for id_1 and if source is books or poster. 
#' Then joins name from additional_infos df depending in source
#' Does same for id_2.
#' Then joins datas for both together
#' 
#' not really good implemented yet,  because dependent on candidates$books_additional_infos which is quite unstructured
#' 
get_candidates_names <- function(data) {
  candidate_1 <- data %>% 
    dplyr::distinct(id, source_1, id_1)
  
  if(candidate_1$source_1 == "book") {
    candidate_1 <- candidate_1 %>% 
      dplyr::left_join(candidates$books_additional_infos %>% 
                         dplyr::distinct(author_id, name_1 = author), by = c("id_1" = "author_id"))
  } else if (candidate_1$source_1 == "poster") { 
    candidate_1 <- candidate_1 %>% 
      dplyr::left_join(candidates$poster_additional_infos %>% 
                         dplyr::distinct(author_id, name_1 = author), by = c("id_1" = "author_id"))
  } else {
    print("not implemented")
  }
  
  candidate_2 <- data %>% 
    dplyr::distinct(id, source_2, id_2)
  
  if(candidate_2$source_2 == "book") {
    candidate_2 <- candidate_2 %>% 
      dplyr::left_join(candidates$books_additional_infos %>% 
                         dplyr::distinct(author_id, name_2 = author), by = c("id_2" = "author_id"))
  } else if (candidate_2$source_2 == "poster") { 
    candidate_2 <- candidate_2 %>% 
      dplyr::left_join(candidates$poster_additional_infos %>% 
                         dplyr::distinct(author_id, name_2 = author), by = c("id_2" = "author_id"))
  } else {
    print("not implemented")
  }
  
  candidate_names <- dplyr::inner_join(candidate_1, candidate_2, by = "id")
  candidate_names
}


#' Save the decision in dataframe and as a csv file
#'
#' @param data data with similarities
#' @param candidates the two candidates to decide on
#' @param decision: positive, negatove, not_sure, next (no decision)
#' 
save_decision <- function(candidates, decision) {
  
  if (decision == "positive") {
    query <- paste0("UPDATE matching_candidates_authors_books_posters SET decision = 'positive' WHERE id =", candidates$id, ";")
    con <- connect_db()
    dbExecute(con, query)
    dbDisconnect(con); rm(con)
    
    print("it's positive, baby")
    
  } else if (decision == "negative") {
    
    query <- paste0("UPDATE matching_candidates_authors_books_posters SET decision = 'negative' WHERE id =", candidates$id, ";")
    con <- connect_db()
    dbExecute(con, query)
    dbDisconnect(con); rm(con)
    print("nope, not the same")
    
  } else if (decision == "not_sure") {
    query <- paste0("UPDATE matching_candidates_authors_books_posters SET decision = 'not_sure' WHERE id =", candidates$id, ";")
    con <- connect_db()
    dbExecute(con, query)
    dbDisconnect(con); rm(con)
    print("can't decide, sorry. needs to be checked again")
    
  } else if (decision == "next_candidates") {
    print("want to check next candidates")
    return(data)
  }
}
```


Sidebar {.sidebar}
=====================================

This is an entity resolver.
It's about ... 

```{r}
actionButton("button_start", "Start")
```

Page 1
=====================================  

Column {data-width=30%}
-------------------------------------

### Decision

```{r show_buttons}
actionButton("button_positive", "Ja, identisch")
br();br()
actionButton("button_negative", "Nein, verschieden")
br();br()
actionButton("button_not_sure", "Unsicher")
```

```{r get_candidates_from_db}

candidates_to_check <- eventReactive(input$button_start, {
   
    con <- connect_db()
    candidates <- tbl(con, "matching_candidates_authors_books_posters") %>% 
      dplyr::filter(decision == "no_judgement") %>% 
      dplyr::arrange(rank) %>% 
      dplyr::filter(row_number() == 1) %>% 
      dplyr::collect()
    print(candidates)
    DBI::dbDisconnect(con); rm(con)
    return(candidates)
  })

```


Column {data-width=70%}
-------------------------------------
```{r get_candidate_names}
candidate_names <- eventReactive(input$button_start, {
    candidates_to_check() %>% get_candidates_names()
  })
```

### Candidate 1
    
```{r candiate_1_infos}
renderUI({h1(candidate_names() %>% pull(name_1))})
```
  
### Candidate 2
    
```{r candiate_2_infos}
renderUI({h1(candidate_names() %>% pull(name_2))})
```


```{r save_decision_after_click_in_db}

# when button click, then save decision in csv file
# it's an observeEvent, because nothing changes in app
# see: https://mastering-shiny.org/basic-reactivity.html#observers


observeEvent(input$button_positive, {
    print(candidates_to_check())
    save_decision(candidates_to_check(), "positive")
  })
  
observeEvent(input$button_negative, {
    save_decision(candidates_to_check(), "negative")
  })
  
observeEvent(input$button_not_sure, {
    save_decision(candidates_to_check(), "not_sure")
  })
```

<!-- Page 2 -->
<!-- =====================================      -->

<!-- ### Chart 2 -->

<!-- ```{r} -->
<!-- ``` -->
