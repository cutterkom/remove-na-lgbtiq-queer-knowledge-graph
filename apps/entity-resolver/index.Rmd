---
title: "Who Is Who?"
output: 
  flexdashboard::flex_dashboard:
    vertical_layout: scroll
runtime: shiny
---

```{r setup, include=FALSE}
library(flexdashboard)
library(tidyverse)
library(kabrutils)
library(DBI)

load("data/candidates-authors.Rdata")

db_tbl_candidates <- "er_candidates"
```

```{r}
#' get a candidate pair to check
#' 
#' rule to choose
#' - not yet checked: `decision == "no_judgement"`
#' - minimum rank: highest similarity
#' - minimum id: in order to choose when similar rank
#' 
#' @param data dataframe with similarties
#' @return dataframe with 1 row
#' 
get_candidates_to_check <- function(data) {
  data %>% 
    dplyr::filter(decision == "no_judgement" & rank == min(rank), row_number() == 1)
}


#' Get candidates names
#' 
#' Looks for id_1 and if source is books or poster. 
#' Then joins name from additional_infos df depending in source
#' Does same for id_2.
#' Then joins datas for both together
#' 
#' not really good implemented yet,  because dependent on candidates$books_additional_infos which is quite unstructured
#' 
get_candidates_names <- function(data) {
  candidate_1 <- data %>% 
    dplyr::distinct(id, source_1, id_1)
  
  if(candidate_1$source_1 == "book") {
    candidate_1 <- candidate_1 %>% 
      dplyr::left_join(candidates$books_additional_infos %>% 
                         dplyr::distinct(author_id, name_1 = author), by = c("id_1" = "author_id"))
  } else if (candidate_1$source_1 == "poster") { 
    candidate_1 <- candidate_1 %>% 
      dplyr::left_join(candidates$poster_additional_infos %>% 
                         dplyr::distinct(author_id, name_1 = author), by = c("id_1" = "author_id"))
  } else {
    print("not implemented")
  }
  
  candidate_2 <- data %>% 
    dplyr::distinct(id, source_2, id_2)
  
  if(candidate_2$source_2 == "book") {
    candidate_2 <- candidate_2 %>% 
      dplyr::left_join(candidates$books_additional_infos %>% 
                         dplyr::distinct(author_id, name_2 = author), by = c("id_2" = "author_id"))
  } else if (candidate_2$source_2 == "poster") { 
    candidate_2 <- candidate_2 %>% 
      dplyr::left_join(candidates$poster_additional_infos %>% 
                         dplyr::distinct(author_id, name_2 = author), by = c("id_2" = "author_id"))
  } else {
    print("not implemented")
  }
  
  candidate_names <- dplyr::inner_join(candidate_1, candidate_2, by = "id")
  candidate_names
}


#' Save the decision in dataframe and as a csv file
#'
#' @param data data with similarities
#' @param candidates the two candidates to decide on
#' @param decision: positive, negatove, not_sure, next (no decision)
#' 
save_decision <- function(candidates, decision, ...) {
  
  if (decision == "positive") {
    
    if(input$keep_candidate_2_label == TRUE) {
      query <- paste0("UPDATE ", db_tbl_candidates, " SET decision = 'positive', keep_label_2 = 1 WHERE id =", candidates$id, ";")
    } else {
      query <- paste0("UPDATE ", db_tbl_candidates, " SET decision = 'positive' WHERE id =", candidates$id, ";")
    }

    con <- connect_db()
    dbExecute(con, query)
    dbDisconnect(con); rm(con)
    
    print("it's positive, baby")
    
  } else if (decision == "negative") {
    
    query <- paste0("UPDATE ", db_tbl_candidates, " SET decision = 'negative' WHERE id =", candidates$id, ";")
    con <- connect_db()
    dbExecute(con, query)
    dbDisconnect(con); rm(con)
    print("nope, not the same")
    
  } else if (decision == "not_sure") {
    query <- paste0("UPDATE ", db_tbl_candidates, " SET decision = 'not_sure' WHERE id =", candidates$id, ";")
    con <- connect_db()
    dbExecute(con, query)
    dbDisconnect(con); rm(con)
    print("can't decide, sorry. needs to be checked again")
    
  } else if (decision == "next_candidates") {
    print("want to check next candidates")
    return(data)
  }
}
```


Beschreibung {.sidebar}
=====================================

Bei `Start/Next` wird das nächste Kandidatenpaar angezeigt.

```{r}
actionButton("button_start", "Start/Next")
```


### Anmerkungen

* Wenn du dich für `Ja, identisch` entscheidest, wird der Name/das Label von `Candidate 1` behalten. Möchtest du das ändern und lieber den Namen von `Candidate 2` behalten, dann setze bitte den Hacken über dem `Ja`-Button.

* Die Information wird direkt in der Datenbank gespeichert, aber der Merge an sich wird manuell angestoßen.

Page 1
=====================================  

Column {data-width=30%}
-------------------------------------

### Entscheidung

Sind die beiden Entitäten identisch oder nicht? Bist du unsicher?

```{r show_buttons}
checkboxInput("keep_candidate_2_label", "Behalte Name von Candidate 2")
actionButton("button_positive", "Ja, identisch")
hr(); br()
actionButton("button_negative", "Nein, verschieden")
br();hr(); br()
actionButton("button_not_sure", "Unsicher")
br();br()
```

```{r get_candidates_from_db}

candidates_to_check <- eventReactive(input$button_start, {
   
    con <- connect_db()
    candidates <- tbl(con, db_tbl_candidates) %>% 
      dplyr::filter(decision == "no_judgement") %>% 
      dplyr::arrange(rank) %>% 
      dplyr::filter(row_number() == 1) %>% 
      dplyr::collect()
    
    DBI::dbDisconnect(con); rm(con)
    return(candidates)
  })

```


Column {data-width=70%}
-------------------------------------
```{r get_candidate_names}
candidate_names <- eventReactive(input$button_start, {
    candidates_to_check() %>% get_candidates_names()
  })

candidate_sources <- eventReactive(input$button_start, { 
    candidates_to_check() %>% select(source_1, source_2)
  })
```

### Candidate 1
    
```{r candiate_1_infos}

renderUI({
   tagList(
    h1(candidate_names() %>% pull(name_1)),
    p(paste("Source: ", candidate_sources() %>% pull(source_1))),
   
   )
})

renderTable({
   if(candidate_sources() %>% pull(source_1) == "book") {
     inner_join(candidates_to_check() %>% distinct(source_1, id_1), 
           candidates$books_additional_infos %>% select(author_id, title = name, subtitle, publisher, isbn, location, year), 
           by = c("id_1" = "author_id")) %>% 
  select(-contains("source_"), -contains("id_")) 
    }
})


```
  
### Candidate 2
    
```{r candiate_2_infos}

renderUI({
   tagList(
    h1(candidate_names() %>% pull(name_2)),
    p(paste("Source: ", candidate_sources() %>% pull(source_2)))
   )
})

renderTable({
   if(candidate_sources() %>% pull(source_2) == "book") {
     inner_join(candidates_to_check() %>% distinct(source_2, id_2), 
           candidates$books_additional_infos %>% select(author_id, title = name, subtitle, publisher, isbn, location, year), 
           by = c("id_2" = "author_id")) %>% 
  select(-contains("source_"), -contains("id_")) 
    }
})
```


```{r save_decision_after_click_in_db}

# when button click, then save decision in csv file
# it's an observeEvent, because nothing changes in app
# see: https://mastering-shiny.org/basic-reactivity.html#observers


observeEvent(input$button_positive, {
  save_decision(candidates_to_check(), "positive", input$keep_candidate_2_label)
  # after decision for YES, set checkbox back to default state
  updateCheckboxInput(session,"keep_candidate_2_label", value = FALSE)
  })
  
observeEvent(input$button_negative, {
  save_decision(candidates_to_check(), "negative")
  })
  
observeEvent(input$button_not_sure, {
  save_decision(candidates_to_check(), "not_sure")
  })
```

<!-- Page 2 -->
<!-- =====================================      -->

<!-- ### Chart 2 -->

<!-- ```{r} -->
<!-- ``` -->
